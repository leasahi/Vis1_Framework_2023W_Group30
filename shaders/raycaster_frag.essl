precision highp sampler3D;
uniform sampler3D volume;
uniform vec3 volumeScale;

 flat in vec3 transformedEye;
 in vec3 rayDirection;


vec2 intersect_box(vec3 orig, vec3 dir) {
	const vec3 box_min = vec3(0);
	const vec3 box_max = vec3(1);
	vec3 inv_dir = 1.0 / dir;
	vec3 tmin_tmp = (box_min - orig) * inv_dir;
	vec3 tmax_tmp = (box_max - orig) * inv_dir;
	vec3 tmin = min(tmin_tmp, tmax_tmp);
	vec3 tmax = max(tmin_tmp, tmax_tmp);
	float t0 = max(tmin.x, max(tmin.y, tmin.z));
	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	return vec2(t0, t1);
}

void main(){
	vec3 dir = normalize(rayDirection);
	vec2 hit = intersect_box(transformedEye, dir);
	if (hit.x > hit.y) {
		discard;
	}
	hit.x = max(hit.x, 0.0);

	// start position
	vec3 start = transformedEye + hit.x * dir;

	// steps
	vec3 dt_vec = 1.0 / (vec3(volumeScale) * abs(dir));
	float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));

	// previous voxel
	vec3 rayPosPrev = start;
	float voxelPrev = texture(volume, rayPosPrev.xyz).r;

	// current voxel
	vec3 rayPosCurr = start;
	float voxelCurr;

	// actual position of the first hit
	vec3 fragPos = vec3(0.5);

	// accumulated color and alpha
	vec3 colAcc = vec3(0);
	float alphaAcc = 0.0;

	// step along ray
	for(float t = hit.x; t < hit.y; t += dt){

		// read current voxel value
		rayPosCurr += dir * dt;
		voxelCurr = texture(volume, rayPosCurr.xyz).r;


		// not very nice variable names, somehow hacked in ;)
		if(voxelCurr > alphaAcc){
			alphaAcc = voxelCurr;
			colAcc = vec3(1.0);
		}

	}
	// set fragment color
    gl_FragColor = vec4(colAcc, alphaAcc);
}